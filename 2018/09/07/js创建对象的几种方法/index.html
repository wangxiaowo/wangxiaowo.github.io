<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.工厂模式缺点：没有解决怎样知道一个对象类型的问题 2.构造函数模式与工厂模式不同之处：1.没有显示的创建对象2.直接将属性和方法赋值给this3.没有return语句 要创建Person的实例，必须使用new操作符，经历了以下四个步骤  1.创建了一个新对象2.将构造函数的作用域赋给新对象（this就指向了这个对象）3.执行构造函数中的代码（为这个对象添加属性和方法）4.返回这个对象  存在的">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2018/09/07/js创建对象的几种方法/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.工厂模式缺点：没有解决怎样知道一个对象类型的问题 2.构造函数模式与工厂模式不同之处：1.没有显示的创建对象2.直接将属性和方法赋值给this3.没有return语句 要创建Person的实例，必须使用new操作符，经历了以下四个步骤  1.创建了一个新对象2.将构造函数的作用域赋给新对象（this就指向了这个对象）3.执行构造函数中的代码（为这个对象添加属性和方法）4.返回这个对象  存在的">
<meta property="og:image" content="https://img-blog.csdn.net/20180505174728831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180505174748235?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180505174828449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180505174846301?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180505174903505?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180505174935483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180505174953710?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180505175024115?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180505175036597?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180505175050806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:updated_time" content="2018-09-07T13:09:45.972Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="1.工厂模式缺点：没有解决怎样知道一个对象类型的问题 2.构造函数模式与工厂模式不同之处：1.没有显示的创建对象2.直接将属性和方法赋值给this3.没有return语句 要创建Person的实例，必须使用new操作符，经历了以下四个步骤  1.创建了一个新对象2.将构造函数的作用域赋给新对象（this就指向了这个对象）3.执行构造函数中的代码（为这个对象添加属性和方法）4.返回这个对象  存在的">
<meta name="twitter:image" content="https://img-blog.csdn.net/20180505174728831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-js创建对象的几种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/07/js创建对象的几种方法/" class="article-date">
  <time datetime="2018-09-07T13:09:45.900Z" itemprop="datePublished">2018-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.<strong>工厂模式</strong><br><img src="https://img-blog.csdn.net/20180505174728831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><em>缺点</em>：没有解决怎样知道一个对象类型的问题</p>
<p><strong>2.构造函数模式</strong><br><img src="https://img-blog.csdn.net/20180505174748235?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><em>与工厂模式不同之处：</em><br>1.没有显示的创建对象<br>2.直接将属性和方法赋值给this<br>3.没有return语句</p>
<p>要创建<code>Person</code>的实例，必须使用<code>new</code>操作符，经历了以下四个步骤</p>
<blockquote>
<p>1.创建了一个新对象<br>2.将构造函数的作用域赋给新对象（this就指向了这个对象）<br>3.执行构造函数中的代码（为这个对象添加属性和方法）<br>4.返回这个对象</p>
</blockquote>
<p><em>存在的缺点</em>：每个方法在每个实例上都要被重新创建一遍<br>eg.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person1 = new Person(&quot;wxw&quot;, 18, &quot;student&quot;);</span><br><span class="line"></span><br><span class="line">var person2 = new Person(&quot;wxo&quot;, 48, &quot;teacher&quot;);</span><br></pre></td></tr></table></figure>
<p><code>person1</code> 和 <code>person2</code> 都有一个<code>sayName</code>的方法，但这个方法不是同一个function的实例。因为函数也是一个对象，所以在每定义一个函数时，就相当于实例化了一个对象。所以每个<code>Person</code>实例都包含了一个不同<code>Funcion</code>的实例（用来显示<code>name</code>属性）。导致不同实例的同名函数是不相等的。<br>可以这么理解：<code>this.sayName = new Function(){&quot;alert(this.name)&quot;}</code>;</p>
<p><em>改进方法</em>：<br><img src="https://img-blog.csdn.net/20180505174828449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<blockquote>
<p>切记：函数名是一个指向函数的指针！！！</p>
</blockquote>
<p><em>缺点：</em></p>
<ul>
<li><p>在全局作用域中定义的函数只能被某个对象调用</p>
</li>
<li><p>若有很多方法时，要定义很多个类似的全局函数，没有封装性。</p>
</li>
</ul>
<p> <strong>3.原型模式</strong><br>我们创建的每个函数都有<code>prototype</code>属性，该属性是一个指针，指向一个对象。可以利用这个属性来定义由特定类型的所有实例所共享的属性和方法<br><img src="https://img-blog.csdn.net/20180505174846301?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><em>来理解下原型对象</em></p>
<p>只要创建了一个新函数，就会为这函数创建一个<code>prototype</code>属性，指向函数的原型对象。而每个原型对象都会自动获得一个<code>constructor</code>(构造函数)属性，指向这个prototype属性所在的函数。即<code>Person.prototype.constructor
== Person;  //true</code> 当调用构造函数创建一个实例后，这个实例内部包含一个指针（<strong>proto</strong>)，指向构造函数原型对象。与构造函数无关。</p>
<p>缺点：</p>
<ul>
<li>1.不能通过对象实例重写原型中的值</li>
<li>2.要重复写很多<code>Person.prototype</code>，麻烦</li>
<li>3.属性共享导致引用类型值的属性，被一个实例修改后，会影响所有实例的改引用类型值</li>
</ul>
<p>为了解决2，提出了对象字面量的写法<br><img src="https://img-blog.csdn.net/20180505174903505?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>注意</strong>，使用对象字面量的形式会创建一个新对象，所以就相当于为<code>Person.prototype</code>赋给了一个新对象，导致，<code>construct</code>属性不再指向<code>Person了。</code><br>分析下上面那个例子。</p>
<blockquote>
<p>使用对象字面量创建了一个对象（可以直接理解成创建了一个新函数），这个函数在创建的同时就会创建他的<code>prototype</code>属性，指向<code>Object.prototype</code>,而这个<code>Object.prottotype</code>也会自动获得<code>constructor</code>属性，指向Object。所以，<code>Person.prototype.constructor
== Object; //true.</code> 导致通过<code>constructor</code>属性已经无法确定对象的类型了。所以为了解决这个问题，需要显示指定<code>constructor</code>的值。</p>
</blockquote>
<p>修改后如下：<br><img src="https://img-blog.csdn.net/20180505174935483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>为了解决1，3缺点，提出</p>
<p><strong>4. 组合使用构造函数模式和原型模式</strong><br><img src="https://img-blog.csdn.net/20180505174953710?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>5 动态原型模式</strong><br>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型<br><img src="https://img-blog.csdn.net/20180505175024115?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>注意</strong>：在使用动态原型模式时，不能使用对象字面量重写原型。因为在已经创建实例的情况下重写原型，会切断现有实例与新原型之间的联系</p>
<p><strong>6.寄生构造模式</strong><br><em>基本思想</em>：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象<br><img src="https://img-blog.csdn.net/20180505175036597?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>除了使用<code>new</code>操作符并把使用的包装函数叫做构造函数外，这个模式跟工厂模式一模一样。<br><strong>注意</strong>：返回的对象与构造函数或者与构造函数的原型属性之间没有任何关系</p>
<p><strong>7.稳妥的构造函数模式</strong><br>稳妥构造函数模式与寄生构造函数类似模式，但有两点不同：<br>1.新创建对象的实例方法不引用<code>this</code>;<br>2.不使用<code>new</code>操作符调用构造函数<br><img src="https://img-blog.csdn.net/20180505175050806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/07/js创建对象的几种方法/" data-id="cjls15hax0002jcqddf4jtrad" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/09/07/JavaScript的继承/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/07/js创建对象的几种方法/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/09/07/JavaScript的继承/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/09/07/从vue-cli中学习webpack的配置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/03/13/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>