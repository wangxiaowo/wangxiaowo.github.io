<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-js创建对象的几种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/07/js创建对象的几种方法/" class="article-date">
  <time datetime="2018-09-07T13:09:45.900Z" itemprop="datePublished">2018-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.<strong>工厂模式</strong><br><img src="https://img-blog.csdn.net/20180505174728831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><em>缺点</em>：没有解决怎样知道一个对象类型的问题</p>
<p><strong>2.构造函数模式</strong><br><img src="https://img-blog.csdn.net/20180505174748235?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><em>与工厂模式不同之处：</em><br>1.没有显示的创建对象<br>2.直接将属性和方法赋值给this<br>3.没有return语句</p>
<p>要创建<code>Person</code>的实例，必须使用<code>new</code>操作符，经历了以下四个步骤</p>
<blockquote>
<p>1.创建了一个新对象<br>2.将构造函数的作用域赋给新对象（this就指向了这个对象）<br>3.执行构造函数中的代码（为这个对象添加属性和方法）<br>4.返回这个对象</p>
</blockquote>
<p><em>存在的缺点</em>：每个方法在每个实例上都要被重新创建一遍<br>eg.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person1 = new Person(&quot;wxw&quot;, 18, &quot;student&quot;);</span><br><span class="line"></span><br><span class="line">var person2 = new Person(&quot;wxo&quot;, 48, &quot;teacher&quot;);</span><br></pre></td></tr></table></figure>
<p><code>person1</code> 和 <code>person2</code> 都有一个<code>sayName</code>的方法，但这个方法不是同一个function的实例。因为函数也是一个对象，所以在每定义一个函数时，就相当于实例化了一个对象。所以每个<code>Person</code>实例都包含了一个不同<code>Funcion</code>的实例（用来显示<code>name</code>属性）。导致不同实例的同名函数是不相等的。<br>可以这么理解：<code>this.sayName = new Function(){&quot;alert(this.name)&quot;}</code>;</p>
<p><em>改进方法</em>：<br><img src="https://img-blog.csdn.net/20180505174828449?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<blockquote>
<p>切记：函数名是一个指向函数的指针！！！</p>
</blockquote>
<p><em>缺点：</em></p>
<ul>
<li><p>在全局作用域中定义的函数只能被某个对象调用</p>
</li>
<li><p>若有很多方法时，要定义很多个类似的全局函数，没有封装性。</p>
</li>
</ul>
<p> <strong>3.原型模式</strong><br>我们创建的每个函数都有<code>prototype</code>属性，该属性是一个指针，指向一个对象。可以利用这个属性来定义由特定类型的所有实例所共享的属性和方法<br><img src="https://img-blog.csdn.net/20180505174846301?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><em>来理解下原型对象</em></p>
<p>只要创建了一个新函数，就会为这函数创建一个<code>prototype</code>属性，指向函数的原型对象。而每个原型对象都会自动获得一个<code>constructor</code>(构造函数)属性，指向这个prototype属性所在的函数。即<code>Person.prototype.constructor
== Person;  //true</code> 当调用构造函数创建一个实例后，这个实例内部包含一个指针（<strong>proto</strong>)，指向构造函数原型对象。与构造函数无关。</p>
<p>缺点：</p>
<ul>
<li>1.不能通过对象实例重写原型中的值</li>
<li>2.要重复写很多<code>Person.prototype</code>，麻烦</li>
<li>3.属性共享导致引用类型值的属性，被一个实例修改后，会影响所有实例的改引用类型值</li>
</ul>
<p>为了解决2，提出了对象字面量的写法<br><img src="https://img-blog.csdn.net/20180505174903505?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>注意</strong>，使用对象字面量的形式会创建一个新对象，所以就相当于为<code>Person.prototype</code>赋给了一个新对象，导致，<code>construct</code>属性不再指向<code>Person了。</code><br>分析下上面那个例子。</p>
<blockquote>
<p>使用对象字面量创建了一个对象（可以直接理解成创建了一个新函数），这个函数在创建的同时就会创建他的<code>prototype</code>属性，指向<code>Object.prototype</code>,而这个<code>Object.prottotype</code>也会自动获得<code>constructor</code>属性，指向Object。所以，<code>Person.prototype.constructor
== Object; //true.</code> 导致通过<code>constructor</code>属性已经无法确定对象的类型了。所以为了解决这个问题，需要显示指定<code>constructor</code>的值。</p>
</blockquote>
<p>修改后如下：<br><img src="https://img-blog.csdn.net/20180505174935483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>为了解决1，3缺点，提出</p>
<p><strong>4. 组合使用构造函数模式和原型模式</strong><br><img src="https://img-blog.csdn.net/20180505174953710?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>5 动态原型模式</strong><br>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型<br><img src="https://img-blog.csdn.net/20180505175024115?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>注意</strong>：在使用动态原型模式时，不能使用对象字面量重写原型。因为在已经创建实例的情况下重写原型，会切断现有实例与新原型之间的联系</p>
<p><strong>6.寄生构造模式</strong><br><em>基本思想</em>：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象<br><img src="https://img-blog.csdn.net/20180505175036597?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>除了使用<code>new</code>操作符并把使用的包装函数叫做构造函数外，这个模式跟工厂模式一模一样。<br><strong>注意</strong>：返回的对象与构造函数或者与构造函数的原型属性之间没有任何关系</p>
<p><strong>7.稳妥的构造函数模式</strong><br>稳妥构造函数模式与寄生构造函数类似模式，但有两点不同：<br>1.新创建对象的实例方法不引用<code>this</code>;<br>2.不使用<code>new</code>操作符调用构造函数<br><img src="https://img-blog.csdn.net/20180505175050806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/07/js创建对象的几种方法/" data-id="cjls15hax0002jcqddf4jtrad" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript的继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/07/JavaScript的继承/" class="article-date">
  <time datetime="2018-09-07T13:09:25.401Z" itemprop="datePublished">2018-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1.原型链</strong><br>将原型链作为继承的主要实现方式，利用原型让一个引用类型继承另一个引用类型的属性和方法。<br><em>前景回顾构造函数、原型和实例之间的关系：</em></p>
<blockquote>
<p>每个构造函数都有个属性<code>prototype</code>指向原型，原型有个<code>constructor</code>属性指向构造函数，每个实例都有个内部指针指向原型</p>
</blockquote>
<p>所以，只要让一个原型对象等于另一个类型的实例，就可以继承另一个类型的所有属性和方法<br><img src="https://img-blog.csdn.net/20180506001142177?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>实现的本质是</strong>：重写了原型对象，以一个新类型的实例代替。所以，原来存在于<code>SuperType</code>中的所有属性和方法，现在都存在了<code>SubType.prototype</code>中了。</p>
<p><em>总结下：</em></p>
<ul>
<li>1.<code>instance</code>里有实例属性<code>subproperty:false</code></li>
<li>2.<code>SubType.prototype</code>里有实例属性<code>property:true</code>,原型方法<code>getSubValue</code></li>
<li>3.<code>SuperType.prototype</code>里有原型方法<code>getSuperValue</code></li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<p>1.给原型添加方法的代码一定要放在替换原型的语句之后。很重要！！！<br>2.不能使用对象字面量创建原型方法。因为这样会重写原型链。</p>
</blockquote>
<p><em>缺点：</em></p>
<ul>
<li>1.由于通过原型来实现继承时，原型实际上会变成另一个类型的实例。则原先的实例属性会变成现在的原型属性了。所以所有的实例都会共享这个原型属性。当这个原型属性是引用类型时就会出现问题。</li>
<li>2.在创建子类型的实例时，不能向超类型的构造函数传递参数</li>
</ul>
<p>为了解决1，产生了</p>
<p><strong>2.借用构造函数</strong></p>
<p><em>实现方法：在子类型构造函数内部调用超类型的构造函数</em><br><img src="https://img-blog.csdn.net/20180506001411588?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>通过使用<code>call</code>或者<code>apply</code>方法，在未来新创建的<code>SubType</code>实例的环境下调用了<code>SuperType</code>构造函数。这样就会在新<code>SubType</code>对象上执行<code>SuperType()</code>函数中定义的所有对象初始化代码</p>
<p>为了解决2，则<br><img src="https://img-blog.csdn.net/20180506001509867?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>在<code>SubType</code>函数内部调用<code>SuperType</code>构造函数时，实际上是为<code>SubType</code>的实例设置了<code>name</code>属性。</p>
<p><em>缺点：</em></p>
<ul>
<li>1.方法都在构造函数中定义，无法很好的复用</li>
<li>2.在超类型的原型中定义的方法，对子类型来说也是不可见的</li>
</ul>
<p><strong>3.组合继承</strong><br>将原型链和借用构造函数的技术结合在一起。思路为：使用原型链实现对原型属性和方法的继承，使用构造函数来实现对实例属性的继承。<br><img src="https://img-blog.csdn.net/20180506001617489?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>通过组合继承。使<code>SubType</code>拥有实例属性：<code>name,colors,age</code>,拥有原型方法：<code>sayName(),sayAge().</code></p>
<p><strong>4.原型式继承</strong><br><em>原理：借助原型可以基于原有的对象创建对象</em>，具体如下：<br><img src="https://img-blog.csdn.net/20180506001651701?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<blockquote>
<p>分析：<code>object</code>函数里创建了一个构造函数<code>F</code>，把已有对象<code>o</code>赋值给<code>F</code>的原型对象，然后返回一个<code>F</code>的实例。则这个实例共享对象<code>o</code>的所有属性和方法，实际上就是完成了第对象<code>o</code>的浅复制。</p>
</blockquote>
<p><code>ECMAScript5</code>新增<code>Object.create()</code>方法规范了原型式继承，接受两个参数：一个用作新对象的原型和一个为新对象定义额外属性的对象，这两个参数都是可选的。<br>在只传入一个参数的情况下，<code>Object.create()与object()</code>方法的行为相同。</p>
<p><em>缺点：包含引用值的属性会被所有的实例所共享</em></p>
<p><strong>5.寄生式继承</strong><br><img src="https://img-blog.csdn.net/20180506001907764?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<blockquote>
<p>分析：基于<code>person</code>创建了一个新对象<code>anotherPerson</code>,并且拥有<code>person</code>的属性和方法，还拥有自己的<code>sayHi()</code>方法</p>
</blockquote>
<p><em>缺点：每个对象都拥有一个不同的<code>sayHi()</code>方法，不能做到函数复用。</em></p>
<p><strong>6.寄生组合式继承</strong></p>
<p><em>实现原理</em>：使用寄生式继承来继承超类型的原型，然后再降结果指定给子类型的原型<br><img src="https://img-blog.csdn.net/20180506001850323?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5ODUzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><em>分析：</em></p>
<blockquote>
<p>在<code>inheritPrototype</code>函数中。通过<code>object()</code>函数，把superType.prototype赋值给<code>prototype</code>，使得<code>prototype</code>就是<code>superType.prototype</code>的一个副本，导致<code>subType.prototype</code>(即子类型的原型）拥有父类型原型的所有属性和方法。</p>
</blockquote>
<p><em>优点：最多只调用了一次<code>SuperType</code>构造函数，并且因此避免了在<code>SubType.prototype</code>上创建不必要的属性</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/07/JavaScript的继承/" data-id="cjls15h7w0000jcqdbpq4dn1h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从vue-cli中学习webpack的配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/07/从vue-cli中学习webpack的配置/" class="article-date">
  <time datetime="2018-09-07T13:08:27.932Z" itemprop="datePublished">2018-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h3><p>webpack 3.6.0</p>
<h4 id="build-目录"><a href="#build-目录" class="headerlink" title="build 目录"></a>build 目录</h4><pre><code>webpack.base.conf.js
webpack.dev.conf.js
webpack.prod.conf.js
webpack.test.conf.js
</code></pre><p>分别对应着公共配置项、开发、生产和测试环境的配置。然后使用webpack-merge把这些公共配置项和环境特定的配置项merge起来，成为一个完整的配置项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;)</span><br><span class="line">const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)</span><br><span class="line"></span><br><span class="line">const devWebpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这三个环境不仅有一部分配置不同，更关键的是，每个配置中用 webpack.DefinePlugin 向代码注入了 NODE_ENV 这个环境变量。</p>
<p>这个变量在不同环境下有不同的值，比如 dev 环境下就是 development。这些环境变量的值是在 config 文件夹下的配置文件中定义的。Webpack 首先从配置文件中读取这个值，然后注入。比如这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// build/webpack.dev.conf.js</span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.DefinePlugin(&#123;</span><br><span class="line">    &apos;process.env&apos;: require(&apos;../config/dev.env.js&apos;)</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// config/dev.env.js</span><br><span class="line">module.exports =&#123;</span><br><span class="line">  NODE_ENV: &apos;&quot;development&quot;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种区分不同的环境，并给环境变量设置不同的值的实践，让我们开启了编译时按环境对代码进行针对性优化的可能。</p>
<h4 id="html在webpack中的配置"><a href="#html在webpack中的配置" class="headerlink" title="html在webpack中的配置"></a>html在webpack中的配置</h4><p>以commonJS模块化机制向外输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在webpack.base.conf.js中的配置</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, &apos;../&apos;),</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/main.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    publicPath: process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<p>HTML打包我们需要安装引入html-webpack-plugin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// 在module.exports里配置我们的plugins(插件)：</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env&apos;: require(&apos;../config/dev.env&apos;)</span><br><span class="line">    &#125;), </span><br><span class="line">    new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.</span><br><span class="line">    new webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">    // https://github.com/ampedandwired/html-webpack-plugin</span><br><span class="line">    new HtmlWebpackPlugin(&#123; //将模板的头部和尾部添加css和js模板,dist 目录发布到服务器上，项目包。可以直接上线</span><br><span class="line">      filename: &apos;index.html&apos;,</span><br><span class="line">      template: &apos;index.html&apos;,</span><br><span class="line">      inject: true</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p>
<p>配置好后，在终端输入npm run dev后webpack将我们的html打包好并且自动将我们的js引进来</p>
<h4 id="css在webpack的配置"><a href="#css在webpack的配置" class="headerlink" title="css在webpack的配置"></a>css在webpack的配置</h4><h5 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h5><p>在执行npm run build之后并没有我们的css,因为webpack配置里 css in js。即打包时是吧我们的css打包进js里的。所以引入extract-text-webpack=p;ugin插件将css从js里面剥离出来.<br>require机制：在我们打包的过程中，文件的引用require按照顺序来打包。这就是文件依赖的机制。</p>
<h4 id="js在webpack中的配置"><a href="#js在webpack中的配置" class="headerlink" title="js在webpack中的配置"></a>js在webpack中的配置</h4><p>由于很多浏览器并不支持es6.所以需要引用babel将es6代码编译成es5.</p>
<ol>
<li>新建.babelrc文件进行配置。</li>
<li>安装babel并在webpack.config.base.js里的modules/rules下进行配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">babel-loader babel-core babel-preset-env //babel基本的三个文件</span><br><span class="line">&#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="图片资源在webpack中的配置"><a href="#图片资源在webpack中的配置" class="headerlink" title="图片资源在webpack中的配置"></a>图片资源在webpack中的配置</h4><ol>
<li>src目录下新建一个assets文件放置图片。安装file-loader根据文件地址加载文件</li>
<li>在webpack.config.base.js里的module/rules</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="别名-在webpack中的配置"><a href="#别名-在webpack中的配置" class="headerlink" title="别名(@)在webpack中的配置"></a>别名(@)在webpack中的配置</h4><p>在vue-cli中我们经常@一个文件夹，其意思就是在src目录下，现在我们去一探究竟。在exports下，注意跟module同级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">   extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class="line">   alias: &#123;</span><br><span class="line">     &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;),</span><br><span class="line">     &apos;common&apos;: path.resolve(__dirname, &apos;../src/common&apos;),</span><br><span class="line">     &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p>
<h4 id="其他一些静态资源在webpack中的配置"><a href="#其他一些静态资源在webpack中的配置" class="headerlink" title="其他一些静态资源在webpack中的配置"></a>其他一些静态资源在webpack中的配置</h4><ol>
<li><p>src下其他的文件直接复制到dist目录下，并不是每个文件都需要打包处理的，很多资源可能直接就可以复制过去。使用我们的 CopyWebpackPlugin插件</p>
</li>
<li><p>引用框架 jquery lodash工具库是很多组件会复用的，省去了import。使用webpack.ProvidePlugin插件</p>
</li>
</ol>
<h4 id="npm-run-dev-发生了什么"><a href="#npm-run-dev-发生了什么" class="headerlink" title="npm run dev 发生了什么"></a>npm run dev 发生了什么</h4><p>在vue-cli中我们启动监听npm run dev可以时时监控我们src下文件的改动，那他到底发生了什么呢。在webpack里其实创建了一个node进程，通过webpack-dev-server其内部封装了一个node的express模块，其配置项如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//package.json中的配置</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;node build/build.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  //webpack.dev.conf.js中的配置</span><br><span class="line">   devServer: &#123;</span><br><span class="line">    before(app) &#123;</span><br><span class="line">      app.get(&apos;/api/seller&apos;, function(req, res) &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">          errno: 0,</span><br><span class="line">          data: seller</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">      app.get(&apos;/api/goods&apos;, function(req, res) &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">          errno: 0,</span><br><span class="line">          data: goods</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">      app.get(&apos;/api/ratings&apos;, function(req, res) &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">          errno: 0,</span><br><span class="line">          data: ratings</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, ////服务于webpack-dev-server  内部封装了一个express</span><br></pre></td></tr></table></figure></p>
<h4 id="webpack4-的变化"><a href="#webpack4-的变化" class="headerlink" title="webpack4 的变化"></a>webpack4 的变化</h4><p>详细可见：<a href="https://juejin.im/post/5b304f1f51882574c72f19b0" target="_blank" rel="noopener">https://juejin.im/post/5b304f1f51882574c72f19b0</a></p>
<h5 id="开发和生产环境的区分"><a href="#开发和生产环境的区分" class="headerlink" title="开发和生产环境的区分"></a>开发和生产环境的区分</h5><p> Webpack4引入了mode这个选项。这个选项的值可以是development或者production.</p>
<p>设置了 mode 之后会把 process.env.NODE_ENV 也设置为 development 或者 production。然后在 production 模式下，会默认开启 UglifyJsPlugin 等等一堆插件</p>
<p>Webpack 4 下如果需要一个 test 环境，那 test 环境的 mode 也是 development。因为 mode 只有开发和生产两种，测试环境应该是属于开发阶段。</p>
<h5 id="Code-Splitting"><a href="#Code-Splitting" class="headerlink" title="Code Splitting"></a>Code Splitting</h5><p>Webpack 4 下还有一个大改动，就是废弃了 CommonsChunkPlugin，引入了 optimization.splitChunks 这个选项。</p>
<p>optimization.splitChunks 默认是不用设置的。如果 mode 是 production，那 Webpack 4 就会开启 Code Splitting。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认 Webpack 4 只会对按需加载的代码做分割。如果我们需要配置初始加载的代码也加入到代码分割中，可以设置 splitChunks.chunks 为 &apos;all&apos;。</span><br></pre></td></tr></table></figure></p>
<h5 id="Long-term-caching"><a href="#Long-term-caching" class="headerlink" title="Long-term caching"></a>Long-term caching</h5><p>Long-term caching 这里，基本的操作和 Webpack 3 是一样的。不过 Webpack 3 的 Long-term caching 在操作的时候，有个小问题，这个问题是关于 chunk 内容和 hash 变化不一致的：<br>在公共代码 Vendor 内容不变的情况下，添加 entry，或者 external 依赖，或者异步模块的时候，Vendor 的 hash 会改变。</p>
<p>Webpack 内部维护了一个自增的 id，每个 chunk 都有一个 id。所以当增加 entry 或者其他类型 chunk 的时候，id 就会变化，导致内容没有变化的 chunk 的 id 也发生了变化。</p>
<p>应对方案是，使用 webpack.NamedChunksPlugin 把 chunk id 变为一个字符串标识符，这个字符包一般就是模块的相对路径。这样模块的 chunk id 就可以稳定下来</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/07/从vue-cli中学习webpack的配置/" data-id="cjls15h970001jcqdmhy53dtz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/13/hello-world/" class="article-date">
  <time datetime="2018-03-13T05:47:24.535Z" itemprop="datePublished">2018-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/13/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/13/hello-world/" data-id="cjls15hbd0003jcqdx2kfteqz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/07/js创建对象的几种方法/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/09/07/JavaScript的继承/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/09/07/从vue-cli中学习webpack的配置/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/03/13/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>